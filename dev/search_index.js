var documenterSearchIndex = {"docs":
[{"location":"#GadgetSearch","page":"Home","title":"GadgetSearch","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GadgetSearch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#GadgetSearch._find_weight-Tuple{Int64, Vector{UInt32}, Vector{UInt32}, Any, Any, Any, Bool}","page":"Home","title":"GadgetSearch._find_weight","text":"_find_weight(vertex_num, target_masks, wrong_masks, optimizer, env, objective, allow_defect)\n\nFind vertex weights using optimization to distinguish target and wrong maximal independent sets.\n\nArguments\n\nvertex_num::Int: Number of vertices\ntarget_masks::Vector{UInt32}: Bit masks for target MIS (should have equal energy)\nwrong_masks::Vector{UInt32}: Bit masks for wrong MIS (should have higher energy)\noptimizer: Optimization solver\nenv: Environment for the optimizer\nobjective: Objective function\nallow_defect::Bool: Whether to allow defective gadgets\n\nReturns\n\nVector{Float64}: Vertex weights if solution found, empty vector otherwise\n\n\n\n\n\n","category":"method"},{"location":"#GadgetSearch.find_matching_gadget-Tuple{GraphLoader}","page":"Home","title":"GadgetSearch.find_matching_gadget","text":"find_matching_gadget(loader; filter=nothing, limit=nothing, keys_range=nothing)\n\nFind gadgets matching a given filter function from the graph loader.\n\nArguments\n\nloader::GraphLoader: The graph loader containing candidate graphs\n\nKeywords\n\nfilter=nothing: Filter function to apply to each graph\nlimit::Union{Int,Nothing}=nothing: Maximum number of graphs to check\nkeys_range::Union{Nothing, Vector{Int}}=nothing: Specific range of keys to search\n\nReturns\n\nVector{Gadget}: Vector of matching gadgets\n\n\n\n\n\n","category":"method"},{"location":"#GadgetSearch.find_maximal_independent_sets-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Home","title":"GadgetSearch.find_maximal_independent_sets","text":"find_maximal_independent_sets(g)\n\nFind all maximal independent sets of a graph using bit masks.\n\nArguments\n\ng::SimpleGraph{Int}: The input graph\n\nReturns\n\nTuple{Vector{UInt32}, Int}: Bit masks representing maximal independent sets and their count\n\nNote\n\nThis function supports graphs with at most 32 vertices due to UInt32 limitations.\n\n\n\n\n\n","category":"method"},{"location":"#GadgetSearch.generate_full_grid_udg-Tuple{GadgetSearch.LatticeType, Int64, Int64}","page":"Home","title":"GadgetSearch.generate_full_grid_udg","text":"generate_full_grid_udg(lattice::LatticeType, nx::Int, ny::Int; path::String=\"udg.g6\") -> String\n\nGenerate unit disk graphs on a grid lattice with boundary pins and save to file.\n\nArguments\n\nlattice: Type of lattice (Square or Triangular)\nnx: Number of inner points in x direction\nny: Number of inner points in y direction\npath: Output file path for saving graphs (default: \"udg.g6\")\n\nReturns\n\nString: Path to the saved graph file\n\nDetails\n\nGenerates all possible UDGs by placing pins on boundary positions and  connecting vertices within unit distance on the specified lattice type.\n\n\n\n\n\n","category":"method"},{"location":"#GadgetSearch.make_filter-Tuple{BitMatrix, Any, Any}","page":"Home","title":"GadgetSearch.make_filter","text":"make_filter(truth_table, optimizer, env; kwargs...)\n\nCreate a filter closure for graph search that checks if a graph can implement the given truth table.\n\nArguments\n\ntruth_table::BitMatrix: The target truth table to implement\noptimizer: Optimization solver for weight finding\nenv: Environment for the optimizer\n\nKeywords\n\nconnected::Bool=false: Whether to require connected graphs only\nobjective=nothing: Objective function for optimization\nallow_defect::Bool=false: Whether to allow defective gadgets\nmax_samples::Int=1000: Maximum samples for weight enumeration\npin_candidates::Union{Nothing, Vector{Vector{Int}}}=nothing: Candidate pin combinations\n\nReturns\n\nFunction: Filter function that takes (graph, pos, pinset) and returns (weights, truthtable, pin)\n\n\n\n\n\n","category":"method"},{"location":"#GadgetSearch.match_rows_by_pinset-Tuple{Vector{UInt32}, BitMatrix, Vector{Int64}}","page":"Home","title":"GadgetSearch.match_rows_by_pinset","text":"match_rows_by_pinset(masks, truth_table, pin_set)\n\nMatch truth table rows to maximal independent sets based on pin configurations.\n\nArguments\n\nmasks::Vector{UInt32}: Bit masks representing maximal independent sets\ntruth_table::BitMatrix: The target truth table\npin_set::Vector{Int}: Pin positions to consider\n\nReturns\n\nVector{Vector{Int}}: For each truth table row, indices of matching maximal independent sets\n\n\n\n\n\n","category":"method"},{"location":"#GadgetSearch.search_by_truth_tables-Tuple{GraphLoader, Vector{BitMatrix}}","page":"Home","title":"GadgetSearch.search_by_truth_tables","text":"search_by_truth_tables(loader, truth_tables; kwargs...)\n\nSearch for multiple truth tables by reusing the graph search functionality.\n\nArguments\n\nloader::GraphLoader: The graph loader containing candidate graphs\ntruth_tables::Vector{BitMatrix}: Truth tables to search for\n\nKeywords\n\nbit_num: Number of bits for the gadget\noptimizer: Optimization solver to use for weight finding\nenv=nothing: Environment for the optimizer\nconnected::Bool=false: Whether to require connected graphs only\nobjective=nothing: Objective function for optimization\nallow_defect::Bool=false: Whether to allow defective gadgets\nlimit=nothing: Maximum number of graphs to search\nmax_samples::Int=100: Maximum samples for weight enumeration\nsave_path::String=\"results.json\": Path to save intermediate results\npin_candidates::Union{Nothing, Vector{Vector{Int}}}=nothing: Candidate pin combinations\n\nReturns\n\nTuple{Vector{Gadget}, Vector{BitMatrix}}: Found gadgets and failed truth tables\n\n\n\n\n\n","category":"method"},{"location":"#GadgetSearch.solve_weight_enumerate","page":"Home","title":"GadgetSearch.solve_weight_enumerate","text":"solve_weight_enumerate(mis_result, target_mis_indices_all, vertex_num, optimizer; kwargs...)\n\nSolve for vertex weights by enumerating all combinations of target MIS indices.\n\nArguments\n\nmis_result::Vector{UInt32}: Maximal independent sets as bit masks\ntarget_mis_indices_all::Vector{Vector{Int}}: Target MIS indices for each truth table row\nvertex_num::Int: Number of vertices in the graph\noptimizer: Optimization solver to use\n\nKeywords\n\nenv=nothing: Environment for the optimizer\nobjective=nothing: Objective function for optimization\nallow_defect::Bool=false: Whether to allow defective gadgets\nmax_samples::Int=1000: Maximum samples for enumeration (currently unused)\n\nReturns\n\nVector{Float64}: Vertex weights if solution found, empty vector otherwise\n\n\n\n\n\n","category":"function"},{"location":"#GadgetSearch.unit_disk_graph-Tuple{AbstractVector, Real}","page":"Home","title":"GadgetSearch.unit_disk_graph","text":"unit_disk_graph(locs::AbstractVector, unit::Real) -> SimpleGraph\n\nCreate a unit disk graph from given locations. Two vertices are connected  if their Euclidean distance is less than the unit distance.\n\nArguments\n\nlocs: Vector of vertex locations\nunit: Unit distance threshold for edge creation\n\nReturns\n\nSimpleGraph: The constructed unit disk graph\n\n\n\n\n\n","category":"method"}]
}
