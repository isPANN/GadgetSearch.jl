var documenterSearchIndex = {"docs":
[{"location":"generated/trangular_Rydberg_example/#Search-for-Rydberg-Gadgets-on-Triangular-Lattice","page":"Rydberg Gadgets on Triangular Lattice","title":"Search for Rydberg Gadgets on Triangular Lattice","text":"This example demonstrates how to search for Rydberg gadgets using:\n\nRydbergModel: State space is restricted to Maximal Independent Sets (MIS)\nUnit Disk Graphs (UDG): Edges connect vertices within unit distance\nVertex weights only: Energy E(σ) = Σᵢ hᵢσᵢ\n\nNotes:\n\nThe search can be expensive. Tweak max_samples, lattice size, and pin_candidates\n\nusing GadgetSearch\nusing HiGHS\nusing Combinatorics\nusing FileIO, ImageShow\n\nDefine truth tables for 2-input, 1-output logic gates\n\ntruth_tables = [\n    TruthTableConstraint(BitMatrix([0 0 0; 1 0 1; 0 1 1; 1 1 1])),   # OR\n    TruthTableConstraint(BitMatrix([0 0 0; 1 0 0; 0 1 0; 1 1 1])),   # AND\n    TruthTableConstraint(BitMatrix([0 0 1; 1 0 1; 0 1 1; 1 1 0])),   # NAND\n    TruthTableConstraint(BitMatrix([0 0 1; 1 0 0; 0 1 0; 1 1 0])),   # NOR\n    TruthTableConstraint(BitMatrix([0 0 0; 1 0 1; 0 1 1; 1 1 0]))    # XOR\n]\n\nGenerate Unit Disk Graph dataset on triangular lattice The UDG constraint means only nearby atoms can interact (Rydberg blockade)\n\ngenerate_full_grid_udg(Triangular(), 2, 2; path=pkgdir(GadgetSearch, \"examples\", \"rydberg_dataset.g6\"))\n\ndataloader = GraphLoader(pkgdir(GadgetSearch, \"examples\", \"rydberg_dataset.g6\"))\n\nSearch using RydbergModel explicitly\n\nRydbergModel uses MIS (Maximal Independent Sets) as the state space\nOnly vertex weights (h) are optimized\nObjective minimizes sum of vertex weights\n\nresults, failed = search_gadgets(\n    RydbergModel,           # Explicitly use Rydberg model\n    dataloader,\n    truth_tables;\n    optimizer=HiGHS.Optimizer,\n    pin_candidates=collect(Combinatorics.combinations(1:4, 3)),\n    allow_defect=true,\n    objective=h -> sum(h),  # Only vertex weights for Rydberg\n    save_path=joinpath(pkgdir(GadgetSearch, \"examples\"), \"triangular_Rydberg_results.json\"),\n    max_result_num=10,\n    max_samples=10000,\n    check_connectivity=true\n)\n\nprintln(\"================================\")\nprintln(\"   RYDBERG MODEL SEARCH RESULTS\")\nprintln(\"================================\")\n@info \"Results: $(length(results)) truth tables searched\"\nfor (i, tt_results) in enumerate(results)\n    @info \"Truth table $(i-1): $(length(tt_results)) gadgets found\"\nend\n\n@info \"Cache statistics: $(GadgetSearch.get_cache_stats())\"\nGadgetSearch.clear_cache!()","category":"section"},{"location":"generated/trangular_Rydberg_example/#Visualize-found-gadgets","page":"Rydberg Gadgets on Triangular Lattice","title":"Visualize found gadgets","text":"labels = [\"OR\", \"AND\", \"NAND\", \"NOR\", \"XOR\"]\n\nfor (i, label) in enumerate(labels)\n    if !isempty(results[i])\n        outpath = pkgdir(GadgetSearch, \"examples\", \"gadget_$(label).png\")\n        GadgetSearch.plot_gadget(results[i][1], outpath; show_weights=true, round_weights=true)\n        @info \"Saved $label gate to $outpath\"\n    end\nend","category":"section"},{"location":"generated/trangular_Rydberg_example/#Check-correctness-using-Rydberg-model","page":"Rydberg Gadgets on Triangular Lattice","title":"Check correctness using Rydberg model","text":"The check_gadget function validates ground states using MIS\n\nfor (i, label) in enumerate(labels)\n    if !isempty(results[i])\n        gadget = results[i][1]\n        println(\"\\n===== Checking $(label) gate (Rydberg/MIS) =====\")\n        println(\"Pins: $(gadget.pins)\")\n        println(\"Vertex weights: $(gadget.vertex_weights)\")\n        println(check_gadget_rydberg(gadget; _return_info=true))\n    end\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/triangular_QUBO_example/#Search-for-QUBO-Gadgets-on-Triangular-Lattice","page":"QUBO Gadgets on Triangular Lattice","title":"Search for QUBO Gadgets on Triangular Lattice","text":"This example demonstrates how to search for QUBO gadgets using:\n\nQUBOModel: State space includes ALL 2^n binary configurations\nComplete graphs: All vertex pairs are connected\nVertex + Edge weights: Energy E(σ) = Σᵢ hᵢσᵢ + Σᵢⱼ Jᵢⱼσᵢσⱼ\n\nNotes:\n\nQUBO search is more general but computationally more expensive\nState constraints are specified directly as ground state strings\n\nusing GadgetSearch\nusing HiGHS\nusing Combinatorics\nusing FileIO, ImageShow\n\nDefine state constraints for QUBO Each constraint specifies which pin configurations should be ground states Format: StateConstraint([\"pin1pin2pin3\", ...])\n\nconstraints = [\n    StateConstraint([\"001\", \"011\", \"101\", \"111\"]),  # OR-like: ground states when output=1 for inputs (0,1), (1,0), (1,1)\n    StateConstraint([\"000\", \"010\", \"100\", \"111\"]),  # AND-like: ground states when output=1 only for input (1,1)\n    StateConstraint([\"000\", \"011\", \"101\", \"110\"]),  # XOR-like: ground states when output=1 for inputs with odd number of 1s\n]\n\nGenerate Complete Graph dataset on triangular lattice All vertices are connected (no distance restriction like UDG)\n\ngenerate_full_grid_graph(Triangular(), 2, 3; path=pkgdir(GadgetSearch, \"examples\", \"qubo_dataset.g6\"))\n\ndataloader = GraphLoader(pkgdir(GadgetSearch, \"examples\", \"qubo_dataset.g6\"))\n\nSearch using QUBOModel explicitly\n\nQUBOModel uses ALL 2^n states (not just MIS)\nBoth vertex weights (h) and edge weights (J) are optimized\nObjective minimizes sum of h and J\n\nresults, failed = search_gadgets(\n    QUBOModel,              # Explicitly use QUBO model\n    dataloader,\n    constraints;\n    optimizer=HiGHS.Optimizer,\n    allow_defect=true,\n    objective=(h, J) -> sum(h) + sum(J),  # Minimize total weights (linear)\n    save_path=joinpath(pkgdir(GadgetSearch, \"examples\"), \"triangular_QUBO_results.json\"),\n    max_result_num=5,\n    max_samples=5000,\n    check_connectivity=true\n)\n\n@show failed\nprintln(\"================================\")\nprintln(\"    QUBO MODEL SEARCH RESULTS\")\nprintln(\"================================\")\n@info \"Results: $(length(results)) constraints searched\"\nlabels = [\"OR-like\", \"AND-like\", \"XOR-like\"]\nfor (i, label) in enumerate(labels)\n    @info \"Constraint '$label': $(length(results[i])) gadgets found\"\nend\n\n@info \"Cache statistics: $(GadgetSearch.get_cache_stats())\"\nGadgetSearch.clear_cache!()","category":"section"},{"location":"generated/triangular_QUBO_example/#Examine-found-QUBO-gadgets","page":"QUBO Gadgets on Triangular Lattice","title":"Examine found QUBO gadgets","text":"QUBO gadgets have both vertex and edge weights\n\nfor (i, label) in enumerate(labels)\n    if !isempty(results[i])\n        gadget = results[i][1]\n        @info \"\"\"===== Found QUBO gadget for '$label' =====\n        Constraint: $(gadget.constraint.ground_states)\n        Pins: $(gadget.pins)\n        Vertex weights (h): $(gadget.vertex_weights)\n        Edge weights (J): $(gadget.edge_weights)\n        Edge list: $(gadget.edge_list)\n        \"\"\"\n        outpath = pkgdir(GadgetSearch, \"examples\", \"qubo_gadget_$(i).png\")\n        GadgetSearch.plot_gadget(gadget, outpath; show_weights=true, round_weights=true)\n        @info \"Saved to $outpath\"\n    end\nend","category":"section"},{"location":"generated/triangular_QUBO_example/#Check-correctness-using-QUBO-model","page":"QUBO Gadgets on Triangular Lattice","title":"Check correctness using QUBO model","text":"The checkgadgetqubo function validates using ALL states (not just MIS)\n\nfor (i, label) in enumerate(labels)\n    if !isempty(results[i])\n        gadget = results[i][1]\n        println(\"\\n===== Checking '$label' gadget (QUBO/Full state space) =====\")\n        println(check_gadget_qubo(gadget; _return_info=true))\n    end\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"ref/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"ref/#GadgetSearch.EnergyModel","page":"Reference","title":"GadgetSearch.EnergyModel","text":"EnergyModel\n\nAbstract type for energy models. Subtypes define how energy is computed from vertex states.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GadgetSearch.Gadget","page":"Reference","title":"GadgetSearch.Gadget","text":"Gadget{M<:EnergyModel, T<:Real}\n\nA gadget found by the search algorithm.\n\nType Parameters\n\nM: Energy model type (RydbergModel or QUBOModel)\nT: Numeric type for weights\n\nFields\n\nconstraint::GadgetConstraint: The constraint this gadget satisfies\ngraph::SimpleGraph{Int}: The graph structure\npins::Vector{Int}: Pin vertex indices\nvertex_weights::Vector{T}: Vertex weights (hᵢ)\nedge_weights::Vector{T}: Edge weights (Jᵢⱼ), empty for RydbergModel\nedge_list::Vector{Tuple{Int,Int}}: Edge list corresponding to edge_weights\npos::Union{Nothing, Vector{Tuple{Float64, Float64}}}: Vertex positions\n\n\n\n\n\n","category":"type"},{"location":"ref/#GadgetSearch.GadgetConstraint","page":"Reference","title":"GadgetSearch.GadgetConstraint","text":"GadgetConstraint\n\nAbstract type for gadget constraints. Subtypes define what ground states are required.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GadgetSearch.QUBOModel","page":"Reference","title":"GadgetSearch.QUBOModel","text":"QUBOModel <: EnergyModel\n\nEnergy model for general QUBO (Quadratic Unconstrained Binary Optimization).\n\nState space: All 2^n binary configurations\nEnergy: E(σ) = Σᵢ hᵢσᵢ + Σ₍ᵢ,ⱼ₎ Jᵢⱼσᵢσⱼ (vertex + edge weights)\n\n\n\n\n\n","category":"type"},{"location":"ref/#GadgetSearch.RydbergModel","page":"Reference","title":"GadgetSearch.RydbergModel","text":"RydbergModel <: EnergyModel\n\nEnergy model for Rydberg atom systems.\n\nState space: Maximal Independent Sets (MIS)\nEnergy: E(σ) = Σᵢ hᵢσᵢ (vertex weights only)\n\n\n\n\n\n","category":"type"},{"location":"ref/#GadgetSearch.StateConstraint","page":"Reference","title":"GadgetSearch.StateConstraint","text":"StateConstraint <: GadgetConstraint\n\nConstraint defined by explicit ground state strings (for general QUBO).\n\nFields\n\nground_states::Vector{String}: States that should have equal minimum energy (e.g., [\"00\", \"01\", \"11\"])\npin_num::Int: Number of pin bits\n\n\n\n\n\n","category":"type"},{"location":"ref/#GadgetSearch.TruthTableConstraint","page":"Reference","title":"GadgetSearch.TruthTableConstraint","text":"TruthTableConstraint <: GadgetConstraint\n\nConstraint defined by a truth table (for Rydberg/MIS-based gadgets).\n\nFields\n\ntruth_table::BitMatrix: Truth table where each row is a ground state configuration on pins\n\n\n\n\n\n","category":"type"},{"location":"ref/#GadgetSearch._find_weights","page":"Reference","title":"GadgetSearch._find_weights","text":"_find_weights(::Type{QUBOModel}, ...) -> Union{Nothing, Tuple{Vector{Float64}, Vector{Float64}}}\n\nFind vertex and edge weights for QUBO model.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GadgetSearch._find_weights-2","page":"Reference","title":"GadgetSearch._find_weights","text":"_find_weights(::Type{RydbergModel}, ...) -> Union{Nothing, Vector{Float64}}\n\nFind vertex weights for Rydberg model.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GadgetSearch._graph_hash-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Reference","title":"GadgetSearch._graph_hash","text":"_graph_hash(g::SimpleGraph{Int}) -> UInt64\n\nCreate a hash for graph structure for caching purposes.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch._solve_weights_sampled-Union{Tuple{M}, Tuple{Type{M}, Vector{UInt32}, Vector{Vector{Int64}}, Graphs.SimpleGraphs.SimpleGraph{Int64}, Int64, Vector{Tuple{Int64, Int64}}, Vector{Int64}, Any, Any, Any, Bool, Int64, Vector{Int64}}, Tuple{Type{M}, Vector{UInt32}, Vector{Vector{Int64}}, Graphs.SimpleGraphs.SimpleGraph{Int64}, Int64, Vector{Tuple{Int64, Int64}}, Vector{Int64}, Any, Any, Any, Bool, Int64, Vector{Int64}, Bool}} where M<:EnergyModel","page":"Reference","title":"GadgetSearch._solve_weights_sampled","text":"_solve_weights_sampled(...)\n\nOptimized version for large combination spaces using random sampling.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.check_connectivity_after_removal-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}, Vector{Int64}}","page":"Reference","title":"GadgetSearch.check_connectivity_after_removal","text":"check_connectivity_after_removal(graph, vertices_to_remove)\n\nCheck if a graph remains connected after removing specified vertices.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.check_gadget-Tuple{Gadget}","page":"Reference","title":"GadgetSearch.check_gadget","text":"check_gadget(gadget::Gadget; _return_info::Bool=false, model::Type{<:EnergyModel}=RydbergModel)\n\nValidate a Gadget by computing energies for its state space and reporting the ground state configurations on pins.\n\nArguments\n\ngadget::Gadget: The gadget to check.\n\nKeyword Arguments\n\n_return_info::Bool=false: If true, return a string; otherwise log with @info.\nmodel::Type{<:EnergyModel}=RydbergModel: Energy model to use for validation.\n\nReturns\n\nWhen _return_info is true, returns a formatted String; otherwise returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.check_gadget_qubo-Tuple{Gadget}","page":"Reference","title":"GadgetSearch.check_gadget_qubo","text":"check_gadget_qubo(gadget::Gadget; _return_info::Bool=false)\n\nCheck gadget using QUBO (full state space) model.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.check_gadget_rydberg-Tuple{Gadget}","page":"Reference","title":"GadgetSearch.check_gadget_rydberg","text":"check_gadget_rydberg(gadget::Gadget; _return_info::Bool=false)\n\nCheck gadget using Rydberg (MIS) model.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.clear_cache!-Tuple{}","page":"Reference","title":"GadgetSearch.clear_cache!","text":"clear_cache!()\n\nClear the MIS cache to free memory. Useful for long-running processes.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.complete_graph-Tuple{Int64}","page":"Reference","title":"GadgetSearch.complete_graph","text":"complete_graph(n::Int) -> SimpleGraph\n\nCreate a complete graph with n vertices where every pair of vertices is connected.\n\nArguments\n\nn: Number of vertices\n\nReturns\n\nSimpleGraph: The complete graph K_n\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.find_matching_gadget-Tuple{GraphLoader}","page":"Reference","title":"GadgetSearch.find_matching_gadget","text":"find_matching_gadget(loader; filter=nothing, limit=nothing, keys_range=nothing, max_results=nothing)\n\nFind gadgets matching a given filter function from the graph loader.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.find_maximal_independent_sets-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Reference","title":"GadgetSearch.find_maximal_independent_sets","text":"find_maximal_independent_sets(g)\n\nFind all maximal independent sets of a graph using bit masks with caching.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.generate_full_grid_graph-Tuple{GadgetSearch.LatticeType, Int64, Int64}","page":"Reference","title":"GadgetSearch.generate_full_grid_graph","text":"generate_full_grid_graph(lattice::LatticeType, nx::Int, ny::Int; path::String=\"grid.g6\") -> String\n\nGenerate complete graphs on a grid lattice (without boundary expansion) and save to file. All vertices are connected to each other, regardless of distance.\n\nArguments\n\nlattice: Type of lattice (Square or Triangular) - determines physical positions\nnx: Number of grid points in x direction\nny: Number of grid points in y direction\npath: Output file path for saving graphs (default: \"grid.g6\")\n\nReturns\n\nString: Path to the saved graph file\n\nDetails\n\nGenerates a single complete graph on the nx×ny grid. The physical positions follow the lattice geometry, but edges connect all pairs of vertices.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.generate_full_grid_udg-Tuple{GadgetSearch.LatticeType, Int64, Int64}","page":"Reference","title":"GadgetSearch.generate_full_grid_udg","text":"generate_full_grid_udg(lattice::LatticeType, nx::Int, ny::Int; path::String=\"udg.g6\") -> String\n\nGenerate unit disk graphs on a grid lattice with four boundary pins and save to file.\n\nArguments\n\nlattice: Type of lattice (Square or Triangular)\nnx: Number of inner positions in x direction\nny: Number of inner positions in y direction\npath: Output file path for saving graphs (default: \"udg.g6\")\n\nReturns\n\nString: Path to the saved graph file\n\nDetails\n\nGenerates all possible UDGs by placing pins on boundary positions and  connecting vertices within unit distance on the specified lattice type.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.get_cache_stats-Tuple{}","page":"Reference","title":"GadgetSearch.get_cache_stats","text":"get_cache_stats()\n\nGet statistics about the MIS cache usage.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.get_state_space-Tuple{Type{QUBOModel}, Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Reference","title":"GadgetSearch.get_state_space","text":"get_state_space(::Type{QUBOModel}, graph::SimpleGraph{Int}) -> Tuple{Vector{UInt32}, Int}\n\nGet the state space for QUBO model (all 2^n states).\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.get_state_space-Tuple{Type{RydbergModel}, Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Reference","title":"GadgetSearch.get_state_space","text":"get_state_space(::Type{RydbergModel}, graph::SimpleGraph{Int}) -> Tuple{Vector{UInt32}, Int}\n\nGet the state space for Rydberg model (Maximal Independent Sets).\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.make_filter-Union{Tuple{M}, Tuple{Type{M}, GadgetConstraint, Any, Any}} where M<:EnergyModel","page":"Reference","title":"GadgetSearch.make_filter","text":"make_filter(model_type, constraint, optimizer, env; kwargs...)\n\nCreate a filter closure for graph search that checks if a graph can implement the given constraint.\n\nArguments\n\nmodel_type::Type{<:EnergyModel}: RydbergModel or QUBOModel\nconstraint::GadgetConstraint: The target constraint to implement\noptimizer: Optimization solver for weight finding\nenv: Environment for the optimizer\n\nKeywords\n\nconnected::Bool=false: Whether to require connected graphs only\nobjective=nothing: Objective function for optimization\nallow_defect::Bool=false: Whether to allow zero vertex weights\nmax_samples::Int=1000: Maximum samples for enumeration\npin_candidates::Union{Nothing, Vector{Vector{Int}}}=nothing: Candidate pin combinations\ncheck_connectivity::Bool=true: Whether to check graph connectivity\n\nReturns\n\nFunction: Filter function that takes (graph, pos, pin_set) and returns Gadget or nothing\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.match_constraint_to_states-Tuple{Vector{UInt32}, GadgetConstraint, Vector{Int64}}","page":"Reference","title":"GadgetSearch.match_constraint_to_states","text":"match_constraint_to_states(states, constraint, pin_set)\n\nMatch constraint ground states to full graph states based on pin configuration.\n\nReturns\n\nVector{Vector{Int}}: For each ground state pattern, indices of matching states in the state space\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.parse_state_string-Tuple{String}","page":"Reference","title":"GadgetSearch.parse_state_string","text":"parse_state_string(s::String) -> UInt32\n\nParse a state string like \"01\" or \"110\" to a bit mask. The leftmost character is bit 0 (LSB).\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.search_by_state_constraints-Tuple{GraphLoader, Vector{StateConstraint}}","page":"Reference","title":"GadgetSearch.search_by_state_constraints","text":"search_by_state_constraints(loader, constraints; kwargs...)\n\nSearch for QUBO gadgets by state constraints (convenience function).\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.search_by_truth_tables-Tuple{GraphLoader, Vector{BitMatrix}}","page":"Reference","title":"GadgetSearch.search_by_truth_tables","text":"search_by_truth_tables(loader, truth_tables; kwargs...)\n\nSearch for Rydberg gadgets by truth tables (legacy interface).\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.search_gadgets-Union{Tuple{C}, Tuple{M}, Tuple{Type{M}, GraphLoader, Vector{C}}} where {M<:EnergyModel, C<:GadgetConstraint}","page":"Reference","title":"GadgetSearch.search_gadgets","text":"search_gadgets(model_type, loader, constraints; kwargs...)\n\nUnified search function for both Rydberg and QUBO gadgets.\n\nArguments\n\nmodel_type::Type{<:EnergyModel}: RydbergModel or QUBOModel\nloader::GraphLoader: The graph loader containing candidate graphs\nconstraints::Vector{<:GadgetConstraint}: Constraints to search for\n\nKeywords\n\noptimizer: Optimization solver to use for weight finding\nenv=nothing: Environment for the optimizer\nconnected::Bool=false: Whether to require connected graphs only\nobjective=nothing: Objective function for optimization\nallow_defect::Bool=false: Whether to allow zero vertex weights\nlimit=nothing: Maximum number of graphs to search\nmax_samples::Int=100: Maximum samples for weight enumeration\nsave_path::String=\"results.json\": Path to save intermediate results\npin_candidates::Union{Nothing, Vector{Vector{Int}}}=nothing: Candidate pin combinations\ncheck_connectivity::Bool=true: Whether to check graph connectivity\nmax_result_num::Int=1: Maximum number of results per constraint\n\nReturns\n\nTuple{Vector{Vector{Gadget}}, Vector{<:GadgetConstraint}}: Found gadgets grouped by constraint and failed constraints\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.solve_weights-Union{Tuple{M}, Tuple{Type{M}, Vector{UInt32}, Vector{Vector{Int64}}, Graphs.SimpleGraphs.SimpleGraph{Int64}, Vector{Int64}, Any}, Tuple{Type{M}, Vector{UInt32}, Vector{Vector{Int64}}, Graphs.SimpleGraphs.SimpleGraph{Int64}, Vector{Int64}, Any, Any}, Tuple{Type{M}, Vector{UInt32}, Vector{Vector{Int64}}, Graphs.SimpleGraphs.SimpleGraph{Int64}, Vector{Int64}, Any, Any, Any}, Tuple{Type{M}, Vector{UInt32}, Vector{Vector{Int64}}, Graphs.SimpleGraphs.SimpleGraph{Int64}, Vector{Int64}, Any, Any, Any, Bool}, Tuple{Type{M}, Vector{UInt32}, Vector{Vector{Int64}}, Graphs.SimpleGraphs.SimpleGraph{Int64}, Vector{Int64}, Any, Any, Any, Bool, Int64}, Tuple{Type{M}, Vector{UInt32}, Vector{Vector{Int64}}, Graphs.SimpleGraphs.SimpleGraph{Int64}, Vector{Int64}, Any, Any, Any, Bool, Int64, Bool}} where M<:EnergyModel","page":"Reference","title":"GadgetSearch.solve_weights","text":"solve_weights(model_type, states, target_indices_all, graph, pin_set, optimizer; kwargs...)\n\nUnified weight solver that works for both Rydberg and QUBO models.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.unit_disk_graph-Tuple{AbstractVector, Real}","page":"Reference","title":"GadgetSearch.unit_disk_graph","text":"unit_disk_graph(locs::AbstractVector, unit::Real) -> SimpleGraph\n\nCreate a unit disk graph from given locations. Two vertices are connected  if their Euclidean distance is less than the unit distance.\n\nArguments\n\nlocs: Vector of vertex locations\nunit: Unit distance threshold for edge creation\n\nReturns\n\nSimpleGraph: The constructed unit disk graph\n\n\n\n\n\n","category":"method"},{"location":"#GadgetSearch","page":"Home","title":"GadgetSearch","text":"Documentation for GadgetSearch.\n\n","category":"section"}]
}
