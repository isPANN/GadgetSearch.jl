var documenterSearchIndex = {"docs":
[{"location":"generated/trangular_lattice_example/#Search-for-gadgets-on-triangular-lattice","page":"Gadgets on triangular lattice","title":"Search for gadgets on triangular lattice","text":"","category":"section"},{"location":"generated/trangular_lattice_example/","page":"Gadgets on triangular lattice","title":"Gadgets on triangular lattice","text":"using Pkg\nPkg.add([\"Combinatorics\", \"HiGHS\"])\n\nusing GadgetSearch\nusing HiGHS\nusing Combinatorics","category":"page"},{"location":"generated/trangular_lattice_example/","page":"Gadgets on triangular lattice","title":"Gadgets on triangular lattice","text":"truthtable = GadgetSearch.genericrule(110, (3, 1))","category":"page"},{"location":"generated/trangular_lattice_example/","page":"Gadgets on triangular lattice","title":"Gadgets on triangular lattice","text":"truth_table = BitMatrix.([\n    [0 0 0; 1 0 1; 0 1 1; 1 1 1],   # OR\n    [0 0 0; 1 0 0; 0 1 0; 1 1 1],   # AND\n    [0 0 1; 1 0 1; 0 1 1; 1 1 0],   # NAND = not(AND)\n    [0 0 1; 1 0 0; 0 1 0; 1 1 0],   # NOR  = not(OR)\n    [0 0 0; 1 0 1; 0 1 1; 1 1 0]    # XOR\n]);\n\ngenerate_full_grid_udg(Triangular(), 1, 2; path=\"dataset.g6\")\n\ndataloader = GraphLoader(\"dataset.g6\")","category":"page"},{"location":"generated/trangular_lattice_example/","page":"Gadgets on triangular lattice","title":"Gadgets on triangular lattice","text":"Performance optimization: Reduce maxsamples for faster initial search Increase maxsamples (e.g., 1000) for thorough search if needed","category":"page"},{"location":"generated/trangular_lattice_example/","page":"Gadgets on triangular lattice","title":"Gadgets on triangular lattice","text":"results, failed = search_by_truth_tables(\n           dataloader,\n           truth_table;\n           optimizer=HiGHS.Optimizer,\n           pin_candidates=collect(Combinatorics.combinations(1:4, 3)),\n           allow_defect=true,\n           objective=x->sum(x),\n           max_result_num=10,\n           max_samples=10000,  # Reduced from default 100 for faster execution\n           check_connectivity=true\n       )\n\n@show size(results)","category":"page"},{"location":"generated/trangular_lattice_example/","page":"Gadgets on triangular lattice","title":"Gadgets on triangular lattice","text":"Display results structure","category":"page"},{"location":"generated/trangular_lattice_example/","page":"Gadgets on triangular lattice","title":"Gadgets on triangular lattice","text":"println(\"--------------------------------\")\n@info \"Results structure: $(length(results)) truth tables\"\nfor (i, tt_results) in enumerate(results)\n    @info \"Truth table $(i-1): $(length(tt_results)) gadgets found\"\nend","category":"page"},{"location":"generated/trangular_lattice_example/","page":"Gadgets on triangular lattice","title":"Gadgets on triangular lattice","text":"Check cache performance","category":"page"},{"location":"generated/trangular_lattice_example/","page":"Gadgets on triangular lattice","title":"Gadgets on triangular lattice","text":"@info \"Cache statistics after search: $(GadgetSearch.get_cache_stats())\"","category":"page"},{"location":"generated/trangular_lattice_example/","page":"Gadgets on triangular lattice","title":"Gadgets on triangular lattice","text":"Uncomment to clear cache if memory is an issue: GadgetSearch.clear_cache!()","category":"page"},{"location":"generated/trangular_lattice_example/","page":"Gadgets on triangular lattice","title":"Gadgets on triangular lattice","text":"Plot gadgets for each truth table","category":"page"},{"location":"generated/trangular_lattice_example/","page":"Gadgets on triangular lattice","title":"Gadgets on triangular lattice","text":"for (tt_idx, tt_results) in enumerate(results)\n    for (gadget_idx, gadget) in enumerate(tt_results)\n        GadgetSearch.plot_gadget(gadget, \"gadget$(tt_idx)_$(gadget_idx).pdf\"; show_weights=true)\n    end\nend","category":"page"},{"location":"generated/trangular_lattice_example/","page":"Gadgets on triangular lattice","title":"Gadgets on triangular lattice","text":"","category":"page"},{"location":"generated/trangular_lattice_example/","page":"Gadgets on triangular lattice","title":"Gadgets on triangular lattice","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ref/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"ref/#GadgetSearch._find_weight","page":"Reference","title":"GadgetSearch._find_weight","text":"_find_weight(vertex_num, target_masks, wrong_masks, optimizer, env, objective, allow_defect)\n\nFind vertex weights using optimization to distinguish target and wrong maximal independent sets.\n\nArguments\n\nvertex_num::Int: Number of vertices\ntarget_masks::Vector{UInt32}: Bit masks for target MIS (should have equal energy)\nwrong_masks::Vector{UInt32}: Bit masks for wrong MIS (should have higher energy)\noptimizer: Optimization solver\nenv: Environment for the optimizer\nobjective: Objective function\nallow_defect::Bool: Whether to allow defective gadgets\n\nReturns\n\nVector{Float64}: Vertex weights if solution found, empty vector otherwise\n\n\n\n\n\n","category":"function"},{"location":"ref/#GadgetSearch._graph_hash-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Reference","title":"GadgetSearch._graph_hash","text":"_graph_hash(g::SimpleGraph{Int}) -> UInt64\n\nCreate a hash for graph structure for caching purposes.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch._solve_weight_sampled","page":"Reference","title":"GadgetSearch._solve_weight_sampled","text":"_solve_weight_sampled(...)\n\nOptimized version for large combination spaces using random sampling.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GadgetSearch.check_connectivity_after_removal-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}, Vector{Int64}}","page":"Reference","title":"GadgetSearch.check_connectivity_after_removal","text":"check_connectivity_after_removal(graph, vertices_to_remove)\n\nCheck if a graph remains connected after removing specified vertices.\n\nArguments\n\ngraph::SimpleGraph{Int}: The original graph\nvertices_to_remove::Vector{Int}: Vertices to remove (0-based indexing for weight array)\n\nReturns\n\nBool: true if the graph remains connected after removal, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.clear_cache!-Tuple{}","page":"Reference","title":"GadgetSearch.clear_cache!","text":"clear_cache!()\n\nClear the MIS cache to free memory. Useful for long-running processes.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.find_matching_gadget-Tuple{GraphLoader}","page":"Reference","title":"GadgetSearch.find_matching_gadget","text":"find_matching_gadget(loader; filter=nothing, limit=nothing, keys_range=nothing, max_results=nothing)\n\nFind gadgets matching a given filter function from the graph loader.\n\nArguments\n\nloader::GraphLoader: The graph loader containing candidate graphs\n\nKeywords\n\nfilter=nothing: Filter function to apply to each graph\nlimit::Union{Int,Nothing}=nothing: Maximum number of graphs to check\nkeys_range::Union{Nothing, Vector{Int}}=nothing: Specific range of keys to search\nmax_results::Union{Int,Nothing}=nothing: Maximum number of results to return (early termination)\n\nReturns\n\nVector{Gadget}: Vector of matching gadgets\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.find_maximal_independent_sets-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Reference","title":"GadgetSearch.find_maximal_independent_sets","text":"find_maximal_independent_sets(g)\n\nFind all maximal independent sets of a graph using bit masks with caching.\n\nArguments\n\ng::SimpleGraph{Int}: The input graph\n\nReturns\n\nTuple{Vector{UInt32}, Int}: Bit masks representing maximal independent sets and their count\n\nNote\n\nThis function supports graphs with at most 32 vertices due to UInt32 limitations. Uses caching to avoid recomputing MIS for identical graphs.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.generate_full_grid_udg-Tuple{GadgetSearch.LatticeType, Int64, Int64}","page":"Reference","title":"GadgetSearch.generate_full_grid_udg","text":"generate_full_grid_udg(lattice::LatticeType, nx::Int, ny::Int; path::String=\"udg.g6\") -> String\n\nGenerate unit disk graphs on a grid lattice with boundary pins and save to file.\n\nArguments\n\nlattice: Type of lattice (Square or Triangular)\nnx: Number of inner points in x direction\nny: Number of inner points in y direction\npath: Output file path for saving graphs (default: \"udg.g6\")\n\nReturns\n\nString: Path to the saved graph file\n\nDetails\n\nGenerates all possible UDGs by placing pins on boundary positions and  connecting vertices within unit distance on the specified lattice type.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.get_cache_stats-Tuple{}","page":"Reference","title":"GadgetSearch.get_cache_stats","text":"get_cache_stats()\n\nGet statistics about the MIS cache usage.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.make_filter-Tuple{BitMatrix, Any, Any}","page":"Reference","title":"GadgetSearch.make_filter","text":"make_filter(truth_table, optimizer, env; kwargs...)\n\nCreate a filter closure for graph search that checks if a graph can implement the given truth table.\n\nArguments\n\ntruth_table::BitMatrix: The target truth table to implement\noptimizer: Optimization solver for weight finding\nenv: Environment for the optimizer\n\nKeywords\n\nconnected::Bool=false: Whether to require connected graphs only\nobjective=nothing: Objective function for optimization\nallow_defect::Bool=false: Whether to allow defective gadgets\nmax_samples::Int=1000: Maximum samples for weight enumeration\npin_candidates::Union{Nothing, Vector{Vector{Int}}}=nothing: Candidate pin combinations\ncheck_connectivity::Bool=true: Whether to check graph connectivity after removing zero-weight vertices\n\nReturns\n\nFunction: Filter function that takes (graph, pos, pinset) and returns (weights, truthtable, pin)\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.match_rows_by_pinset-Tuple{Vector{UInt32}, BitMatrix, Vector{Int64}}","page":"Reference","title":"GadgetSearch.match_rows_by_pinset","text":"match_rows_by_pinset(masks, truth_table, pin_set)\n\nMatch truth table rows to maximal independent sets based on pin configurations.\n\nArguments\n\nmasks::Vector{UInt32}: Bit masks representing maximal independent sets\ntruth_table::BitMatrix: The target truth table\npin_set::Vector{Int}: Pin positions to consider\n\nReturns\n\nVector{Vector{Int}}: For each truth table row, indices of matching maximal independent sets\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.search_by_truth_tables-Tuple{GraphLoader, Vector{BitMatrix}}","page":"Reference","title":"GadgetSearch.search_by_truth_tables","text":"search_by_truth_tables(loader, truth_tables; kwargs...)\n\nSearch for multiple truth tables by reusing the graph search functionality.\n\nArguments\n\nloader::GraphLoader: The graph loader containing candidate graphs\ntruth_tables::Vector{BitMatrix}: Truth tables to search for\n\nKeywords\n\nbit_num: Number of bits for the gadget\noptimizer: Optimization solver to use for weight finding\nenv=nothing: Environment for the optimizer\nconnected::Bool=false: Whether to require connected graphs only\nobjective=nothing: Objective function for optimization\nallow_defect::Bool=false: Whether to allow defective gadgets\nlimit=nothing: Maximum number of graphs to search\nmax_samples::Int=100: Maximum samples for weight enumeration\nsave_path::String=\"results.json\": Path to save intermediate results\npin_candidates::Union{Nothing, Vector{Vector{Int}}}=nothing: Candidate pin combinations\ncheck_connectivity::Bool=true: Whether to check graph connectivity after removing zero-weight vertices\n\nReturns\n\nTuple{Vector{Vector{Gadget}}, Vector{BitMatrix}}: Found gadgets grouped by truth table and failed truth tables\n\n\n\n\n\n","category":"method"},{"location":"ref/#GadgetSearch.solve_weight_enumerate","page":"Reference","title":"GadgetSearch.solve_weight_enumerate","text":"solve_weight_enumerate(mis_result, target_mis_indices_all, vertex_num, optimizer; kwargs...)\n\nSolve for vertex weights by enumerating all combinations of target MIS indices.\n\nArguments\n\nmis_result::Vector{UInt32}: Maximal independent sets as bit masks\ntarget_mis_indices_all::Vector{Vector{Int}}: Target MIS indices for each truth table row\nvertex_num::Int: Number of vertices in the graph\noptimizer: Optimization solver to use\n\nKeywords\n\nenv=nothing: Environment for the optimizer\nobjective=nothing: Objective function for optimization\nallow_defect::Bool=false: Whether to allow defective gadgets\nmax_samples::Int=1000: Maximum samples for enumeration\ngraph::Union{SimpleGraph{Int}, Nothing}=nothing: Original graph for connectivity checking\ncheck_connectivity::Bool=true: Whether to check graph connectivity after removing zero-weight vertices\n\nReturns\n\nVector{Float64}: Vertex weights if solution found, empty vector otherwise\n\n\n\n\n\n","category":"function"},{"location":"ref/#GadgetSearch.unit_disk_graph-Tuple{AbstractVector, Real}","page":"Reference","title":"GadgetSearch.unit_disk_graph","text":"unit_disk_graph(locs::AbstractVector, unit::Real) -> SimpleGraph\n\nCreate a unit disk graph from given locations. Two vertices are connected  if their Euclidean distance is less than the unit distance.\n\nArguments\n\nlocs: Vector of vertex locations\nunit: Unit distance threshold for edge creation\n\nReturns\n\nSimpleGraph: The constructed unit disk graph\n\n\n\n\n\n","category":"method"},{"location":"#GadgetSearch","page":"Home","title":"GadgetSearch","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GadgetSearch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
